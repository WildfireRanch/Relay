# File: agents/mcp_agent.py
# Purpose: Central orchestrator for Relay's multi-agent pipeline
# Roles:
#   - Injects context
#   - Routes user query to appropriate agent (Planner or Codex)
#   - Executes post-agent critic evaluation
#   - Logs plan + critic results into TrainerAgent (with Neo4j memory graph)

import traceback
from typing import Optional

from agents import planner_agent, codex_agent
from agents.critic_agent import run_critics
from agents.trainer_agent import trainer_agent

from services.context_injector import build_context
from core.logging import log_event
from services.queue import queue_action


async def run_mcp(
    query: str,
    files: Optional[list[str]] = None,
    topics: Optional[list[str]] = None,
    role: str = "planner",
    user_id: str = "anonymous",
    debug: bool = False,
):
    """
    Master Control Program (MCP) entrypoint for processing user queries.

    Args:
        query: User question or instruction.
        files: Optional list of filenames for context injection.
        topics: Optional list of markdown topics to include as external context.
        role: Which agent to invoke: "planner" or "codex".
        user_id: For tracking memory, feedback, and usage analytics.
        debug: If True, includes injected context and file metadata in response.

    Returns:
        Dict with agent output, and optionally context/file info if debug is True.
    """

    files = files or []
    topics = topics or []

    # === Step 1: Build injected context ===
    try:
        context_data = build_context(query, files, topics, debug=debug)
        if isinstance(context_data, dict):
            context = context_data["context"]
            files_used = context_data["files_used"]
        else:
            context = context_data
            files_used = []
    except Exception as e:
        log_event("mcp_context_error", {"error": str(e), "trace": traceback.format_exc()})
        return {"error": "Failed to build context."}

    log_event("mcp_context_loaded", {"user": user_id, "files": files_used})

    try:
        # === Step 2: Agent Routing ===
        if role == "planner":
            plan = await planner_agent.ask(query=query, context=context)
            result = {"plan": plan}

        elif role == "codex":
            # === CodexAgent execution ===
            patch_result = await codex_agent.handle(message=query, context=context, user_id=user_id)
            action = patch_result.get("action")

            # Queue patch if one was generated
            if action and action.get("type") == "patch":
                queue_action(action, reason="Generated by MCP Codex")
                patch_result["queued"] = True

            # === Step 3: Run Critics ===
            critics = await run_critics(patch_result, query)
            patch_result["critics"] = critics

            # === Step 4: Log Plan + Critics to TrainerAgent (Neo4j memory graph) ===
            await trainer_agent.ingest_results(
                plan=patch_result,
                critics=critics,
                feedback=None,  # Hook up UI or test input here
                user_id=user_id
            )

            result = patch_result

        else:
            result = {"error": f"Unknown role: {role}"}

        # === Step 5: Final event log + return ===
        log_event("mcp_result", {"user": user_id, "role": role, "result": result})

        if debug:
            return {"result": result, "context": context, "files_used": files_used}

        return result

    except Exception as e:
        log_event("mcp_agent_error", {"role": role, "error": str(e), "trace": traceback.format_exc()})
        return {"error": f"Failed to execute {role} agent."}
